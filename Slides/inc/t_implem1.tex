\section{Le langage F-Safe}

\begin{frame}
  \frametitle{F-Safe}
  \begin{block}{F-Safe est...}
    \begin{itemize}
      \item Un langage de modélisation
      \item Fonctionnel pur
      \item Terminant
      \item Typé statiquement
      \item A types inductifs
      \item A types polymorphes
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Syntaxe concrète}
  \begin{block}{Expressions}
    $a, b ::= x$ \\
    \hspace{1,2cm}| $C(a_1, ..., a_n)$ \\
    \hspace{1,2cm}| $C[\tau_1, ..., \tau_m](a_1, ..., a_n)$ \\
    \hspace{1,2cm}| \textbf{fun} $(a_1:\tau_1, ..., a_n:\tau_n) : \tau \Rightarrow a$ \\
    \hspace{1,2cm}| $a(a_1, ..., a_n)$ \\
    \hspace{1,2cm}| \textbf{let} $(x_1:\tau_1 = a_1, ..., x_n:\tau_n = a_n) \{ a \}$ \\
    \hspace{1,2cm}| \textbf{case} $a_1, ..., a_m \{ | f_1 \Rightarrow b_1 | ... | f_n \Rightarrow b_n \}$
  \end{block}
\end{frame}

%\section{Composants}

%\begin{frame}
%  \frametitle{Diagramme de composants}
%  TODO
%\end{frame}

\section{Algorithme de terminaison}

\subsection{Principes}

\begin{frame}
  \frametitle{}
  \begin{block}{Idées}
    \begin{itemize}
      \item Identifier un ordre bien fondé sur les arguments de fonctions
      \item Construire un graphe d'appels pour les fonctions
        mutuellement récursives
      \item Détecter des cycles dans le graphe d'appels
    \end{itemize}
  \end{block}
\end{frame}

\subsection{Ordre bien fondé}

\begin{frame}
  \frametitle{Ordre bien fondé}
  \begin{block}{Relations}
    3 types de relation :
    \begin{itemize}
    \item \textbf{<} : ``inférieur à''
    \item \textbf{=} : ``égal à''
    \item \textbf{?} : incomparables (peut être une relation ``inférieur à'', ``égal'', ou ``supérieur à'')
    \end{itemize}
  \end{block}
  \begin{block}{Loi de déconstruction}
    Soient $x$ et $y$ des variables, et $C$ un constructeur. Si $x = C(y)$, alors on déduit $y \textbf{<} x$.
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Algorithme}
  \begin{block}{Structure de données}
    \begin{itemize}
    \item Arbre de noms de variables
    \end{itemize}
  \end{block}
  \begin{block}{Algorithme}
    Parcours du corps de la fonction :
    \begin{itemize}
      \item Lors d'une déconstruction ($x = C(y)$), on ajoute le lien de parenté entre les variables ($y < x$)
      \item Lors d'un appel de fonction, on vérifie les parentés entre les variables dans l'arbre
    \end{itemize}
  \end{block}
\end{frame}

\subsection{Matrices de paramètres}

\begin{frame}
  \frametitle{}
  \begin{block}{}
    \begin{itemize}
      \item Construction de la matrice des arguments
    \end{itemize}
  \end{block}
  \begin{block}{Structure de données}
  \end{block}
  \begin{block}{Limites}
    \begin{itemize}
      \item Nécessité de conserver l'ordre des arguments d'une fonction récursive
    \end{itemize}
  \end{block}
\end{frame}

\subsection{Callgraph}
\begin{frame}
  \frametitle{Construction du graphe d'appels}
  \begin{block}{Objectif}
    Représenter tous les appels de fonctions pour détecter d'éventuels appels mutuellement récursifs
  \end{block}
  \begin{block}{Structures de données}
    \begin{itemize}
    \item Le graphe : une Map qui associe un nom de fonction (appelante) à une liste d'arcs sortants
    \item Un arc : la fonction appelée et les noms des paramètres
      ainsi que la matrice associé
    \item Une table pour retenir les fonctions traitées et ne pas parcourir l'AST à l'infini
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{Détection de cycles et terminaison}
  \begin{block}{Cycle : structure de données}
    Une liste de couple
    \begin{itemize}
    \item Nom de la fonction appelante 
    \item Arc du callgraph de la fonction appelante vers fonction appelée
    \end{itemize}
  \end{block}
  \begin{block}{Détection de cycles}
    \begin{itemize}
    \item Parcours du graphe d'appels d'une fonction, en gardant un
      historique des fonctions appelées
    \item Lorsqu'on retombe sur une fonction de l'historique, ajout du
      cycle
    \item Une fois tout les cycles directs obtenus, refaire une passe
      pour composer les cycles entre eux
    \end{itemize}
  \end{block}
\end{frame}

\section{Vers un langage ``fonctionnel''}

\subsection{Typage}

\begin{frame}
  \frametitle{Typage}
  \begin{block}{Caractéristiques}
    \begin{itemize}
    \item Statique
    \item Polymorphe
    \item Assimilable à System F
    \end{itemize}
  \end{block}
  \begin{block}{Implémentation}
    Typechecking en trois passes :
    \begin{itemize}
      \item Vérification du bien-fondé des types déclarés et création d'un Map de schémas de type
      \item Décoration de chaque expression de l'AST avec son type
      \item Vérification des types
    \end{itemize}
  \end{block}
\end{frame}

\subsection{Interprète}

\begin{frame}{Interprète}
  \begin{itemize}
  \item Evaluer le code (AST) à la volée
  \item Environnement pour retenir les valeurs des variables
    \begin{block}{Value}
      type value =\\
      | Cons of string * value list\\
      | Fun of string * string list * typed\_expression\\
    \end{block}
  \end{itemize}
\end{frame}

\begin{frame}{Interprète}
  \begin{itemize}
  \item Remplir l'environnement initial avec les définitions globales
  \item Récursion et $pattern matching$ sur les noeuds de l'AST :
    \begin{itemize}
    \item EVar : liaison del'identifiant à une $value$
    \item EConApp : valeur construite avec une liste d'expressions
    \item ELet : enrichir l'environnement avant d'évaluer le corps du let
    \item EApp : pas d'application partielle, enrichissement de l'environnement avec les valeurs des paramètres puis évaluation du corps
    \item ECase : tester l'\'egalit\'e du constructeur et lier la valeur \`a la variable dans l'environnement au moment d'évaluer l'expression.
    \item possibilit\'e d'imbrication des case.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Exemple}
  \begin{exampleblock}{Programme}
    def is\_even:(nat) $\rightarrow$ bool,is\_odd:(nat) $\rightarrow$ bool =
    let(even:(nat) $\rightarrow$ bool=fun(n:nat) : bool $\Rightarrow$
    case n {\\
      | Zero $\Rightarrow$ True\\
      | Succ(m:nat) $\Rightarrow$ odd(m)\\
    },
    odd:(nat)->bool=fun(n:nat) : bool =>\\
    case n {\\
      | Zero => False\\
      | Succ(m:nat) => case m {\\
        | Zero => True\\
        | Succ(p:nat) => even(m)}\\
    }) { even,odd }\\
    
    is\_even(Succ(Succ(Zero))),
    is\_odd(Succ(Succ(Zero)))
  \end{exampleblock}
\end{frame}

\begin{frame}{Exemple}
\begin{exampleblock}{exécution}
    ./fsafe -i demo/good/even\_odd.fsf 
    
    [X] Function "is\_even" passes termination check
    
    [X] Function "is\_odd" passes termination  check
    
    True()
    
    False()
  \end{exampleblock}
\end{frame}